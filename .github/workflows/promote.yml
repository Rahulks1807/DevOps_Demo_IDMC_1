name: Promote Release via PR (Clean Tag Promotion)

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Existing SemVer tag (e.g., 1.2.3)"
        required: true
        type: string
      target_env:
        description: "Promotion target"
        type: choice
        options: 
          - uat
          - psup
          - prod
        required: true
      force_reset:
        description: "Force reset target branch if diverged (DANGEROUS)"
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      TAG: ${{ steps.out.outputs.TAG }}
      SHA: ${{ steps.out.outputs.SHA }}
      SOURCE: ${{ steps.out.outputs.SOURCE }}
      TARGET: ${{ steps.out.outputs.TARGET }}
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - run: git fetch --all --tags

      - name: Validate SemVer tag & resolve SHA
        id: res
        shell: bash
        run: |
          TAG="${{ github.event.inputs.tag }}"
          if [[ ! "$TAG" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Invalid tag format '$TAG'. Use MAJOR.MINOR.PATCH." >&2; exit 1
          fi
          if ! git rev-parse "refs/tags/$TAG" >/dev/null 2>&1; then
            echo "Tag not found: $TAG" >&2; exit 1
          fi
          echo "sha=$(git rev-parse "refs/tags/$TAG^{commit}")" >> "$GITHUB_OUTPUT"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"

      - name: Map env -> branches
        id: map
        shell: bash
        run: |
          case "${{ github.event.inputs.target_env }}" in
            uat)  echo "src=develop"       >> "$GITHUB_OUTPUT"; echo "tgt=release/uat"  >> "$GITHUB_OUTPUT" ;;
            psup) echo "src=release/uat"   >> "$GITHUB_OUTPUT"; echo "tgt=release/psup" >> "$GITHUB_OUTPUT" ;;
            prod) echo "src=release/psup"  >> "$GITHUB_OUTPUT"; echo "tgt=release/prod" >> "$GITHUB_OUTPUT" ;;
          esac

      - name: Set composite outputs
        id: out
        run: |
          echo "TAG=${{ steps.res.outputs.tag }}"   >> "$GITHUB_OUTPUT"
          echo "SHA=${{ steps.res.outputs.sha }}"   >> "$GITHUB_OUTPUT"
          echo "SOURCE=${{ steps.map.outputs.src }}" >> "$GITHUB_OUTPUT"
          echo "TARGET=${{ steps.map.outputs.tgt }}" >> "$GITHUB_OUTPUT"

  verify-ancestry:
    runs-on: ubuntu-latest
    needs: prepare
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - run: git fetch --all --tags
      
      - name: Ensure tag commit exists in predecessor branch
        shell: bash
        run: |
          SRC="${{ needs.prepare.outputs.SOURCE }}"
          SHA="${{ needs.prepare.outputs.SHA }}"
          git rev-parse --verify "origin/$SRC" >/dev/null 2>&1 || { echo "Missing branch $SRC"; exit 1; }
          git merge-base --is-ancestor "$SHA" "origin/$SRC" || {
            echo "âŒ Tag commit is not in '$SRC'. You must promote in order." >&2
            echo "Tag must exist in: develop â†’ release/uat â†’ release/psup â†’ release/prod" >&2
            exit 1
          }
          echo "âœ… Tag exists in predecessor branch '$SRC'"

  verify-no-divergence:
    runs-on: ubuntu-latest
    needs: prepare
    outputs:
      NEEDS_RESET: ${{ steps.check.outputs.needs_reset }}
      IS_NOOP: ${{ steps.check.outputs.is_noop }}
      TARGET_EXISTS: ${{ steps.check.outputs.target_exists }}
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - run: git fetch --all --tags
      
      - name: Check if target branch has diverged from tag history
        id: check
        shell: bash
        run: |
          TGT="${{ needs.prepare.outputs.TARGET }}"
          SHA="${{ needs.prepare.outputs.SHA }}"
          FORCE="${{ github.event.inputs.force_reset }}"
          
          # Check if target branch exists
          if ! git rev-parse --verify "origin/$TGT" >/dev/null 2>&1; then
            echo "âœ… Target branch '$TGT' doesn't exist yet - will be created"
            echo "target_exists=false" >> "$GITHUB_OUTPUT"
            echo "needs_reset=false" >> "$GITHUB_OUTPUT"
            echo "is_noop=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          echo "target_exists=true" >> "$GITHUB_OUTPUT"
          
          # Check if target is already at or behind the tag (safe to fast-forward)
          if git merge-base --is-ancestor "origin/$TGT" "$SHA"; then
            echo "âœ… Target branch '$TGT' can be cleanly fast-forwarded to tag"
            echo "needs_reset=false" >> "$GITHUB_OUTPUT"
            echo "is_noop=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          # Check if tag is behind target (already promoted)
          if git merge-base --is-ancestor "$SHA" "origin/$TGT"; then
            echo "âš ï¸ Target branch '$TGT' already contains this tag"
            echo "This is a no-op promotion, but PR will be created for tracking"
            echo "needs_reset=false" >> "$GITHUB_OUTPUT"
            echo "is_noop=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          # If we get here, branches have diverged
          if [[ "$FORCE" == "true" ]]; then
            echo "âš ï¸ Target branch '$TGT' has diverged, but force_reset is enabled"
            echo "Target will be RESET to tag (existing commits will be lost)"
            echo "needs_reset=true" >> "$GITHUB_OUTPUT"
            echo "is_noop=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          echo "âŒ Target branch '$TGT' has diverged from tag history!" >&2
          echo "" >&2
          echo "Target branch contains commits not in the tag." >&2
          echo "Release branches should only contain promoted tags." >&2
          echo "" >&2
          echo "To fix this, you can:" >&2
          echo "1. Reset '$TGT' manually: git reset --hard refs/tags/${{ needs.prepare.outputs.TAG }} && git push --force" >&2
          echo "2. Create a new tag that includes the divergent commits" >&2
          echo "3. Re-run this workflow with 'force_reset' enabled (DANGEROUS)" >&2
          exit 1

  ensure-target:
    runs-on: ubuntu-latest
    needs: [prepare, verify-ancestry, verify-no-divergence]
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - run: git fetch --all --tags
      
      - name: Create or update target branch
        shell: bash
        run: |
          TGT="${{ needs.prepare.outputs.TARGET }}"
          SHA="${{ needs.prepare.outputs.SHA }}"
          NEEDS_RESET="${{ needs.verify-no-divergence.outputs.NEEDS_RESET }}"
          TARGET_EXISTS="${{ needs.verify-no-divergence.outputs.TARGET_EXISTS }}"
          
          if [[ "$TARGET_EXISTS" == "false" ]]; then
            echo "Creating $TGT from tag SHA"
            git checkout -b "$TGT" "$SHA"
            git push -u origin "$TGT"
            echo "âœ… Created '$TGT' pointing to tag"
          elif [[ "$NEEDS_RESET" == "true" ]]; then
            echo "âš ï¸ Force resetting '$TGT' to tag SHA"
            git checkout -B "$TGT" "$SHA"
            git push --force -u origin "$TGT"
            echo "âœ… Force reset '$TGT' to tag"
          else
            echo "âœ… Target branch '$TGT' already exists and is in valid state"
          fi

  create-promo-branch:
    runs-on: ubuntu-latest
    needs: [prepare, verify-ancestry, verify-no-divergence, ensure-target]
    outputs:
      BRANCH: ${{ steps.mk.outputs.branch }}
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - run: git fetch --all --tags

      - name: Configure git author
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Create promo branch from target with tag content
        id: mk
        shell: bash
        run: |
          TGT="${{ needs.prepare.outputs.TARGET }}"
          TAG="${{ needs.prepare.outputs.TAG }}"
          SHA="${{ needs.prepare.outputs.SHA }}"
          IS_NOOP="${{ needs.verify-no-divergence.outputs.IS_NOOP }}"
          PROMO_BRANCH="promote/${TAG}-to-${TGT//\//-}"
          
          # Always start from the current target branch
          git checkout -B "$PROMO_BRANCH" "origin/$TGT"
          
          if [[ "$IS_NOOP" == "true" ]]; then
            echo "âš ï¸ Tag already in target - creating no-op promotion for audit trail"
            
            # Add empty commit to create PR
            git commit --allow-empty -m "chore(release): no-op promotion of $TAG to $TGT

            This promotion is a no-op because the target branch already contains this tag.
            Creating this PR for audit trail and tracking purposes.

            Tag: $TAG
            Target: $TGT"
          else
            echo "âœ… Creating promotion: resetting branch content to tag $TAG"
            
            # Reset the branch content to match the tag exactly
            # This preserves the branch's base but updates content to the tag
            git reset --hard "$SHA"
            
            # If the reset resulted in the same state (already at tag), create empty commit
            if git diff --quiet "origin/$TGT" HEAD; then
              echo "Content already matches tag, creating tracking commit"
              git commit --allow-empty -m "chore(release): promote $TAG to $TGT

              Promoting tag $TAG to $TGT.
              Content is already synchronized.

              Tag: $TAG  
              SHA: $SHA
              Target: $TGT"
            fi
          fi
          
          echo "branch=$PROMO_BRANCH" >> "$GITHUB_OUTPUT"
          
          # Push the promo branch
          git push -f origin "$PROMO_BRANCH"
          echo "âœ… Pushed promotion branch: $PROMO_BRANCH"

  open-pr:
    runs-on: ubuntu-latest
    needs: [prepare, verify-no-divergence, create-promo-branch]
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Open PR via GitHub API
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const head  = '${{ needs.create-promo-branch.outputs.BRANCH }}';
            const base  = '${{ needs.prepare.outputs.TARGET }}';
            const tag   = '${{ needs.prepare.outputs.TAG }}';
            const isNoop = '${{ needs.verify-no-divergence.outputs.IS_NOOP }}' === 'true';
            
            const title = `ðŸš€ Promote ${tag} â†’ ${base}`;
            
            let body = `## ðŸš€ Release Promotion
            
            **Tag:** \`${tag}\`  
            **SHA:** \`${{ needs.prepare.outputs.SHA }}\`  
            **Source:** \`${{ needs.prepare.outputs.SOURCE }}\`  
            **Target:** \`${base}\`

            ### What happens when this PR is merged:
            - The \`${base}\` branch will be updated to contain the exact code from tag \`${tag}\`
            - ${isNoop ? 'âš ï¸ This is a **no-op promotion** - the target already contains this tag' : 'The branch will be reset to match the tag content exactly'}
            - Your deployment pipeline will deploy tag \`${tag}\` to the target environment

            ### Merge Instructions:
            âœ… **Use 'Create a merge commit'** or **'Rebase and merge'**  
            âŒ **Do NOT use 'Squash and merge'** - this will lose the exact tag reference

            ### Post-Merge:
            After merging, \`${base}\` will point to the exact content of tag \`${tag}\`.
            `;

            try {
              const { data: pr } = await github.rest.pulls.create({
                owner, repo, head, base, title, body,
                maintainer_can_modify: true, 
                draft: false
              });
              
              core.info(`âœ… PR created: ${pr.html_url}`);
              core.summary.addRaw(`### âœ… Promotion PR Created\n\n**PR:** [#${pr.number}](${pr.html_url})\n**Tag:** ${tag}\n**Target:** ${base}\n**Is No-Op:** ${isNoop}`);
              await core.summary.write();
              
            } catch (e) {
              if (e.status === 422) {
                // Check if PR already exists
                const { data: prs } = await github.rest.pulls.list({
                  owner, repo, state: 'open', head: `${owner}:${head}`, base
                });
                
                if (prs.length > 0) {
                  core.info(`â„¹ï¸ PR already exists: ${prs[0].html_url}`);
                  core.summary.addRaw(`### â„¹ï¸ Promotion PR Already Exists\n\n**PR:** [#${prs[0].number}](${prs[0].html_url})\n**Tag:** ${tag}\n**Target:** ${base}`);
                  await core.summary.write();
                } else {
                  core.setFailed(`Could not create PR. Error: ${e.message}`);
                }
              } else {
                core.setFailed(`PR creation failed: ${e.message}`);
              }
            }

  merge-instructions:
    runs-on: ubuntu-latest
    needs: [prepare, open-pr]
    steps:
      - name: Provide merge instructions
        run: |
          echo "# ðŸ“‹ Promotion Instructions" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## What to do next:" >> $GITHUB_STEP_SUMMARY
          echo "1. Review the promotion PR" >> $GITHUB_STEP_SUMMARY
          echo "2. Verify the changes match tag \`${{ needs.prepare.outputs.TAG }}\`" >> $GITHUB_STEP_SUMMARY
          echo "3. **Important:** Use **'Create a merge commit'** or **'Rebase and merge'** strategy" >> $GITHUB_STEP_SUMMARY
          echo "4. **Do NOT use 'Squash and merge'** - this will lose the exact tag reference" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## After merge:" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ needs.prepare.outputs.TARGET }}\` will contain the exact content from tag \`${{ needs.prepare.outputs.TAG }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Your deployment pipeline will deploy the tag content" >> $GITHUB_STEP_SUMMARY
          echo "- The promotion branch will be auto-deleted by GitHub" >> $GITHUB_STEP_SUMMARY